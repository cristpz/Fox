'use strict'
var __createBinding =
	(this && this.__createBinding) ||
	(Object.create
		? function (o, m, k, k2) {
				if (k2 === undefined) k2 = k
				Object.defineProperty(o, k2, {
					enumerable: true,
					get: function () {
						return m[k]
					},
				})
		  }
		: function (o, m, k, k2) {
				if (k2 === undefined) k2 = k
				o[k2] = m[k]
		  })
var __setModuleDefault =
	(this && this.__setModuleDefault) ||
	(Object.create
		? function (o, v) {
				Object.defineProperty(o, 'default', { enumerable: true, value: v })
		  }
		: function (o, v) {
				o['default'] = v
		  })
var __importStar =
	(this && this.__importStar) ||
	function (mod) {
		if (mod && mod.__esModule) return mod
		var result = {}
		if (mod != null)
			for (var k in mod)
				if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
					__createBinding(result, mod, k)
		__setModuleDefault(result, mod)
		return result
	}
var __importDefault =
	(this && this.__importDefault) ||
	function (mod) {
		return mod && mod.__esModule ? mod : { default: mod }
	}
Object.defineProperty(exports, '__esModule', { value: true })
exports.create = exports.Transform = exports.Logger = void 0
const extendr_1 = require('extendr')
const stream_1 = require('stream')
const rfc_log_levels_1 = __importStar(require('rfc-log-levels'))
const get_current_line_1 = __importDefault(require('get-current-line'))
/**
 * Logger.
 * This is what we write to.
 * It extends from PassThrough and not transform.
 * If you are piping / writing directly to the logger, make sure it corresponds to the correct entry format (as described in `log`).
 *
 * @param args forwarded to {@link Logger#setConfig}
 *
 * @example Creation
 * ``` javascript
 * // Via class
 * import { Logger } from 'caterpillar'
 * const logger = new Logger()
 * // Via create helper
 * const logger = Logger.create()
 * ```
 */
class Logger extends stream_1.PassThrough {
	// ===================================
	// Generic
	// This code is shared between Logger and Transform
	constructor(...args) {
		super(...args)
		this._config = this.getInitialConfig()
		this.setConfig(...args)
	}
	/**
	 * Get the initial configuration.
	 * Initial log levels are fetched from: https://github.com/bevry/rfc-log-levels
	 */
	getInitialConfig() {
		return {
			lineOffset: {
				file: __filename,
				method: /log/i,
			},
			levels: Object.assign({}, rfc_log_levels_1.rfcLogLevels, {
				default: 6,
			}),
		}
	}
	/**
	 * Alternative way of creating an instance of the class without having to use the `new` keyword.
	 */
	static create(...args) {
		return new this(...args)
	}
	/**
	 * Get the current configuration object for this instance.
	 */
	getConfig() {
		return this._config
	}
	/**
	 * Apply the specified configurations to this instance's configuration via deep merging.
	 * @example
	 * ``` javascript
	 * setConfig({a: 1}, {b: 2})
	 * getConfig()  // {a: 1, b: 2}
	 * ```
	 */
	setConfig(...configs) {
		extendr_1.deep(this._config, ...configs)
		this.emit('config', ...configs)
		return this
	}
	/**
	 * Pipe this data to some other writable stream.
	 * If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
	 * @param child stream to be piped to
	 * @returns the result of the pipe operation
	 */
	pipe(child) {
		if (typeof child.setConfig !== 'undefined') {
			child.setConfig(this.getConfig())
			const listener = child.setConfig.bind(child)
			this.on('config', listener)
			child.once('close', () => this.removeListener('config', listener))
		}
		return super.pipe(child)
	}
	// ===================================
	// Logger
	/**
	 * Takes an arguments array and tranforms it into a log entry
	 * @param args
	 */
	getLogEntry(args) {
		const { lineOffset, levels } = this.getConfig()
		const date = new Date().toISOString()
		const lineInfo = get_current_line_1.default(lineOffset)
		const level = args.shift()
		let levelInfo = rfc_log_levels_1.default(level, levels)
		if (levelInfo == null) {
			levelInfo = rfc_log_levels_1.default('default', levels)
			if (levelInfo == null) {
				throw new Error(
					'caterpillar: rfc-log-levels: no default log level configuration was provided'
				)
			}
			args.unshift(level)
		}
		return Object.assign({ date, args }, levelInfo, lineInfo)
	}
	/**
	 * Log the arguments into the logger stream as formatted data with debugging information.
	 * Such that our transformers can deal with it intelligently.
	 *
	 * @param args forwarded to {@link Logger#getLogEntry}
	 *
	 * @example Inputs
	 * ``` javascript
	 * logger.log('note', 'this is working swell')
	 * ```
	 * ``` javascript
	 * logger.log('this', 'worked', 'swell')
	 * ```
	 *
	 * @example Results
	 * ``` json
	 * {
	 * 	"args": ["this is working swell"],
	 * 	"date": "2013-04-25T10:18:25.722Z",
	 * 	"levelNumber": 5,
	 * 	"levelName": "notice",
	 * 	"line": "59",
	 * 	"method": "Object.<anonymous>",
	 * 	"file": "/Users/balupton/some-project/calling-file.js"
	 * }
	 * ```
	 * ``` json
	 * {
	 *		"args": ["this", "worked", "well"],
	 *		"date": "2013-04-25T10:18:26.539Z",
	 *		"levelNumber": 6,
	 *		"levelName": "info",
	 *		"line": "60",
	 *		"method": "Object.<anonymous>",
	 *		"file": "/Users/balupton/some-project/calling-file.js"
	 * }
	 * ```
	 */
	log(...args) {
		// Fetch the log entry
		const entry = this.getLogEntry(args)
		// Write the arguments as an entry to be transformed by our format
		this.write(JSON.stringify(entry))
		// Chain
		return this
	}
}
exports.Logger = Logger
/**
 * Transform.
 * This is a helper for our transforms to be able to process the written log data more easily.
 * All the need to do is extend this class and add their own `format` method.
 * @param args forwarded to {@link Logger#setConfig}
 * @example
 * ``` javascript
 * import {inspect} from 'util'
 * import {Logger, Transform} from 'caterpillar'
 * class Pretty extends Transform {
 * 	format (entry) {
 * 		return inspect(entry, {colors: true})
 * 	}
 * }
 * Logger.create()
 * 	.pipe(Pretty.create())
 * 	.pipe(process.stdout)
 * 	.log('note', 'cool times', 5)
 * ```
 */
class Transform extends stream_1.Transform {
	// ===================================
	// Generic
	// This code is shared between Logger and Transform
	constructor(...args) {
		super(...args)
		this._config = this.getInitialConfig()
		this.setConfig(...args)
	}
	/**
	 * Get the initial configuration option.
	 * Use this to add default/initial configuration to your class.
	 */
	getInitialConfig() {
		return {}
	}
	/**
	 * Alternative way of creating an instance of the class without having to use the `new` keyword.
	 */
	static create(...args) {
		return new this(...args)
	}
	/**
	 * Get the current configuration object for this instance.
	 */
	getConfig() {
		return this._config
	}
	/**
	 * Apply the specified configurations to this instance's configuration via deep merging.
	 * @example
	 * ``` javascript
	 * setConfig({a: 1}, {b: 2})
	 * getConfig()  // {a: 1, b: 2}
	 * ```
	 */
	setConfig(...configs) {
		extendr_1.deep(this._config, ...configs)
		this.emit('config', ...configs)
		return this
	}
	/**
	 * Pipe this data to some other writable stream.
	 * If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
	 * @param child stream to be piped to
	 * @returns the result of the pipe operation
	 */
	pipe(child) {
		if (typeof child.setConfig !== 'undefined') {
			child.setConfig(this.getConfig())
			const listener = child.setConfig.bind(child)
			this.on('config', listener)
			child.once('close', () => this.removeListener('config', listener))
		}
		return super.pipe(child)
	}
	// ===================================
	// Transform
	/**
	 * Transform the written buffer into data we can format
	 * @private
	 * @param chunk
	 * @param encoding
	 * @param next
	 */
	_transform(chunk, encoding, next) {
		let message = chunk.toString()
		try {
			message = this.format(message)
		} catch (err) {
			return next(err)
		}
		if (message && typeof message === 'object') {
			message = JSON.stringify(message)
		}
		return next(null, message)
	}
	/**
	 * Format the written data into whatever we want.
	 * Here is where our transformers work with the written data to enhance it.
	 * By default (without any other transformers at work) this will be a stringified {@link LogEntry}.
	 * @param message
	 */
	format(message) {
		return message
	}
}
exports.Transform = Transform
// Aliases
exports.create = Logger.create.bind(Logger)
exports.default = Logger
