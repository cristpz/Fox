/// <reference types="node" />
import { PassThrough, Transform as _Transform } from 'stream'
import { LevelInfo, LevelsMap } from 'rfc-log-levels'
import { LineOffset, LineInfo } from 'get-current-line'
/** The log entry that caterpillar creates and forwards to the streams */
export interface LogEntry extends LevelInfo, LineInfo {
	/** the iso string of when the log occured */
	date: string
	/** all the arguments that were after the log level */
	args: any[]
}
/** Configuration for caterpillar and the streams */
export interface Configuration {
	[key: string]: any
}
/** Configuration for caterpillar */
export interface CaterpillarConfiguration extends Configuration {
	lineOffset: LineOffset
	levels: LevelsMap
}
/** Streams that caterpillar can pipe to */
export interface ConfigurableStream extends NodeJS.WritableStream {
	setConfig?: (...configs: Configuration[]) => void
}
/**
 * Logger.
 * This is what we write to.
 * It extends from PassThrough and not transform.
 * If you are piping / writing directly to the logger, make sure it corresponds to the correct entry format (as described in `log`).
 *
 * @param args forwarded to {@link Logger#setConfig}
 *
 * @example Creation
 * ``` javascript
 * // Via class
 * import { Logger } from 'caterpillar'
 * const logger = new Logger()
 * // Via create helper
 * const logger = Logger.create()
 * ```
 */
export declare class Logger extends PassThrough {
	protected _config: CaterpillarConfiguration
	/**
	 * Get the initial configuration.
	 * Initial log levels are fetched from: https://github.com/bevry/rfc-log-levels
	 */
	getInitialConfig(): CaterpillarConfiguration
	constructor(...args: any)
	/**
	 * Alternative way of creating an instance of the class without having to use the `new` keyword.
	 */
	static create(...args: any): Logger
	/**
	 * Get the current configuration object for this instance.
	 */
	getConfig(): Configuration
	/**
	 * Apply the specified configurations to this instance's configuration via deep merging.
	 * @example
	 * ``` javascript
	 * setConfig({a: 1}, {b: 2})
	 * getConfig()  // {a: 1, b: 2}
	 * ```
	 */
	setConfig(...configs: Configuration[]): this
	/**
	 * Pipe this data to some other writable stream.
	 * If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
	 * @param child stream to be piped to
	 * @returns the result of the pipe operation
	 */
	pipe<T extends ConfigurableStream>(child: T): T
	/**
	 * Takes an arguments array and tranforms it into a log entry
	 * @param args
	 */
	getLogEntry(args: any): LogEntry
	/**
	 * Log the arguments into the logger stream as formatted data with debugging information.
	 * Such that our transformers can deal with it intelligently.
	 *
	 * @param args forwarded to {@link Logger#getLogEntry}
	 *
	 * @example Inputs
	 * ``` javascript
	 * logger.log('note', 'this is working swell')
	 * ```
	 * ``` javascript
	 * logger.log('this', 'worked', 'swell')
	 * ```
	 *
	 * @example Results
	 * ``` json
	 * {
	 * 	"args": ["this is working swell"],
	 * 	"date": "2013-04-25T10:18:25.722Z",
	 * 	"levelNumber": 5,
	 * 	"levelName": "notice",
	 * 	"line": "59",
	 * 	"method": "Object.<anonymous>",
	 * 	"file": "/Users/balupton/some-project/calling-file.js"
	 * }
	 * ```
	 * ``` json
	 * {
	 *		"args": ["this", "worked", "well"],
	 *		"date": "2013-04-25T10:18:26.539Z",
	 *		"levelNumber": 6,
	 *		"levelName": "info",
	 *		"line": "60",
	 *		"method": "Object.<anonymous>",
	 *		"file": "/Users/balupton/some-project/calling-file.js"
	 * }
	 * ```
	 */
	log(...args: any): this
}
/**
 * Transform.
 * This is a helper for our transforms to be able to process the written log data more easily.
 * All the need to do is extend this class and add their own `format` method.
 * @param args forwarded to {@link Logger#setConfig}
 * @example
 * ``` javascript
 * import {inspect} from 'util'
 * import {Logger, Transform} from 'caterpillar'
 * class Pretty extends Transform {
 * 	format (entry) {
 * 		return inspect(entry, {colors: true})
 * 	}
 * }
 * Logger.create()
 * 	.pipe(Pretty.create())
 * 	.pipe(process.stdout)
 * 	.log('note', 'cool times', 5)
 * ```
 */
export declare class Transform extends _Transform {
	protected _config: Configuration
	/**
	 * Get the initial configuration option.
	 * Use this to add default/initial configuration to your class.
	 */
	getInitialConfig(): Configuration
	constructor(...args: any)
	/**
	 * Alternative way of creating an instance of the class without having to use the `new` keyword.
	 */
	static create(...args: any): Transform
	/**
	 * Get the current configuration object for this instance.
	 */
	getConfig(): Configuration
	/**
	 * Apply the specified configurations to this instance's configuration via deep merging.
	 * @example
	 * ``` javascript
	 * setConfig({a: 1}, {b: 2})
	 * getConfig()  // {a: 1, b: 2}
	 * ```
	 */
	setConfig(...configs: Configuration[]): this
	/**
	 * Pipe this data to some other writable stream.
	 * If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
	 * @param child stream to be piped to
	 * @returns the result of the pipe operation
	 */
	pipe<T extends ConfigurableStream>(child: T): T
	/**
	 * Transform the written buffer into data we can format
	 * @private
	 * @param chunk
	 * @param encoding
	 * @param next
	 */
	_transform(
		chunk: Buffer | string,
		encoding: string,
		next: (error?: Error | null, message?: string) => any
	): any
	/**
	 * Format the written data into whatever we want.
	 * Here is where our transformers work with the written data to enhance it.
	 * By default (without any other transformers at work) this will be a stringified {@link LogEntry}.
	 * @param message
	 */
	format(message: string): any
}
export declare const create: typeof Logger.create
export default Logger
//# sourceMappingURL=index.d.ts.map
