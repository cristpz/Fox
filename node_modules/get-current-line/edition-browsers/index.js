/**
 * Get the information about the line that called this method.
 * @param offset continue until these offset conditions are met, used to continue to the caller
 * @throws if a failure occured creating the line info
 * @example Input
 * ``` javascript
 * import getCurrentLine from 'get-current-line'
 * console.log(getCurrentLine())
 * ```
 * @example Result
 * ``` json
 * {
 * 	"line": "2",
 * 	"method": "Object.<anonymous>",
 * 	"file": "/Users/balupton/some-project/calling-file.js"
 * }
 * ```
 */
export default function getCurrentLine(
	offset = {
		file: __filename,
		method: 'getCurrentLine',
		frames: 0,
	}
) {
	// prepare
	const result = {
		line: -1,
		method: 'unknown',
		file: 'unknown',
	}
	try {
		// Create an error
		const err = new Error()
		let stack, lines
		// And attempt to retrieve it's stack
		// https://github.com/winstonjs/winston/issues/401#issuecomment-61913086
		try {
			stack = err.stack
		} catch (error1) {
			try {
				// @ts-ignore
				const previous = err.__previous__ || err.__previous
				stack = previous && previous.stack
			} catch (error2) {
				stack = null
			}
		}
		// Handle different stack formats
		if (stack) {
			if (Array.isArray(stack)) {
				lines = Array(stack)
			} else {
				lines = stack.toString().split('\n')
			}
		} else {
			lines = []
		}
		// Handle different line formats
		lines = lines
			// Ensure each line item is a string
			.map((line) => (line || '').toString())
			// Filter out empty line items
			.filter((line) => line.length !== 0)
		// Continue
		let found = !offset.file && !offset.method
		let exited = found
		// Parse our lines
		let i = 0
		while (i < lines.length) {
			const line = lines[i]
			// continue
			if (found && exited) {
				const parts = line.split(':')
				if (parts.length >= 2) {
					if (parts[0].indexOf('(') === -1) {
						result.method = 'unknown'
						result.file = parts[0].replace(/^.+?\s+at\s+/, '')
					} else {
						result.method = parts[0]
							.replace(/^.+?\s+at\s+/, '')
							.replace(/\s+\(.+$/, '')
						result.file = parts[0].replace(/^.+?\(/, '')
					}
					result.line = Number(parts[1])
					break
				}
				// found and exited, but not a valid entry, so continue
				++i
				continue
			}
			// continue until found and exited
			if (
				(offset.file &&
					(typeof offset.file === 'string'
						? line.includes(offset.file)
						: offset.file.test(line))) ||
				(offset.method &&
					(typeof offset.method === 'string'
						? line.includes(offset.method)
						: offset.method.test(line)))
			) {
				found = true
				// next item
				++i
				continue
			} else if (found) {
				// exited, apply frame offset and call it a day
				i += offset.frames || 0
				exited = true
				continue
			} else {
				// nothing found yet, next item
				++i
				continue
			}
		}
	} catch (err) {
		throw new Error(`get-current-line: Failed to parse the error stack: ${err}`)
	}
	// Return
	return result
}
